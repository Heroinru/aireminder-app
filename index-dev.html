// --- НАСТРОЙКИ ---
const MIN_SLOT_SIZE = 45; // Минимальное окно (мин), которое считаем деньгами
const SAFE_BUFFER_DAYS = 0; // 0 = Считаем с сегодня, 1 = Считаем с завтра

// --- HELPER FUNCTIONS ---
function normalize(str) {
    if (!str) return "";
    return String(str).toLowerCase().replace(/[^а-яa-z0-9\s]/g, '').trim();
}

// Перевод времени "14:30" -> 870 минут
function timeToMin(t) {
    if (!t) return 0;
    const [h, m] = t.split(':').map(Number);
    return h * 60 + m;
}

// 1. ПОЛУЧЕНИЕ ДАННЫХ
let servicesData = [], visitsData = [], scheduleData = [];
try { servicesData = $('Services').all().map(i => i.json); } catch (e) {}
try { visitsData = $('Visits').all().map(i => i.json); } catch (e) { visitsData = $input.all().map(i => i.json); }
try { scheduleData = $('Schedule').all().map(i => i.json); } catch (e) {}

// 2. АНАЛИЗ УСЛУГ (Считаем средний чек)
let totalServicePrice = 0;
let servicesCount = 0;

servicesData.forEach(svc => {
    let price = parseFloat(String(svc.price).replace(/[^0-9.]/g, '')) || 0;
    if (price > 0) {
        totalServicePrice += price;
        servicesCount++;
    }
});

// Консервативная оценка: Средний чек в час. 
// Если средний чек 3000, то считаем, что минута стоит 50р.
const avgCheck = servicesCount > 0 ? Math.round(totalServicePrice / servicesCount) : 2000;
const pricePerMinute = avgCheck / 60; // <--- УПРОСТИЛИ (избегаем инфляции от коротких услуг)

// 3. ПОДГОТОВКА ДАННЫХ ВИЗИТОВ
const now = new Date();
const currentMonth = now.getMonth(); 
const currentYear = now.getFullYear();

let earnedMonth = 0;      
let forecastMonth = 0;    
let visitsFact = 0;     
let visitsForecast = 0; 
let uniqueClients = new Set();

// Карта занятости: "2026-02-06" -> [{start: 600, end: 720}]
const busyByDate = {}; 

visitsData.forEach(visit => {
    if (!visit.appointment_time) return;
    // Парсим дату как строку, чтобы избежать сдвигов поясов
    // Берём первые 10 символов "2026-02-06" напрямую из ISO, 
    // НО: ISO всегда в UTC. Если визит в 20:00 МСК, в ISO это 17:00. Дата та же.
    // Если визит в 01:00 МСК, в ISO это 22:00 вчера. Дата сдвинется.
    // Для надежности создаем объект даты.
    const vDate = new Date(visit.appointment_time);
    
    // Определяем месяц визита
    if (vDate.getMonth() !== currentMonth || vDate.getFullYear() !== currentYear) return;

    // Статусы
    const status = (visit.visit_status || '').toLowerCase();
    if (status === 'cancelled' || status === 'no_show') return;

    if (visit.client_phone) uniqueClients.add(visit.client_phone);

    // Цена (упрощенно)
    let price = avgCheck;
    if (visit.fixed_price && parseFloat(visit.fixed_price) > 0) price = parseFloat(visit.fixed_price);
    
    // Длительность (упрощенно - берем дефолт 90 мин, если не знаем точно, чтобы не занижать занятость)
    // Лучше посчитать визит длиннее, чем короче, чтобы не завышать "свободное время"
    let duration = 90; 

    // Считаем факт/прогноз
    if (status === 'confirmed') {
        earnedMonth += price;
        visitsFact++;
    } else {
        forecastMonth += price;
        visitsForecast++;
    }

    // --- ГЕОМЕТРИЯ ЗАНЯТОСТИ ---
    // Нам нужно получить локальную дату визита в формате "YYYY-MM-DD"
    // Хак: добавляем 3 часа к UTC времени, чтобы получить МСК дату
    const mskDate = new Date(vDate.getTime() + 3 * 3600 * 1000);
    const dateKey = mskDate.toISOString().split('T')[0];

    const startMin = mskDate.getUTCHours() * 60 + mskDate.getUTCMinutes();
    const endMin = startMin + duration;

    if (!busyByDate[dateKey]) busyByDate[dateKey] = [];
    busyByDate[dateKey].push({ start: startMin, end: endMin });
});

// 4. РАСЧЕТ ПОТЕНЦИАЛА (СКАНИРОВАНИЕ)
let freeMinutesSum = 0;
const daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
const todayDate = now.getDate();

// Начинаем цикл с (Сегодня + SAFE_BUFFER_DAYS)
for (let d = todayDate + SAFE_BUFFER_DAYS; d <= daysInMonth; d++) {
    // Формируем ключ даты "2026-02-08"
    const dayStr = String(d).padStart(2, '0');
    const monthStr = String(currentMonth + 1).padStart(2, '0');
    const dateKey = `${currentYear}-${monthStr}-${dayStr}`;

    // Ищем график
    const sched = scheduleData.find(s => s.work_date && s.work_date.startsWith(dateKey));

    if (sched && sched.start_time && sched.end_time) {
        // Есть график!
        const dayStart = timeToMin(sched.start_time);
        const dayEnd = timeToMin(sched.end_time);

        // Собираем все занятые блоки (Визиты + Обеды)
        let blocks = [];

        // Визиты
        if (busyByDate[dateKey]) {
            blocks.push(...busyByDate[dateKey]);
        }

        // Обеды
        if (sched.breaks) {
            let breaks = [];
            try { breaks = typeof sched.breaks === 'string' ? JSON.parse(sched.breaks) : sched.breaks; } catch(e){}
            if (Array.isArray(breaks)) {
                breaks.forEach(b => {
                    blocks.push({ start: timeToMin(b.start), end: timeToMin(b.end) });
                });
            }
        }
        
        // Сортируем и сливаем блоки
        blocks.sort((a, b) => a.start - b.start);
        
        let merged = [];
        if (blocks.length > 0) {
            let curr = blocks[0];
            for (let i = 1; i < blocks.length; i++) {
                if (blocks[i].start < curr.end) {
                    curr.end = Math.max(curr.end, blocks[i].end);
                } else {
                    merged.push(curr);
                    curr = blocks[i];
                }
            }
            merged.push(curr);
        }

        // Считаем свободное место
        let cursor = dayStart;
        let dayFree = 0;

        merged.forEach(b => {
            // Ограничиваем блок рамками дня
            let bStart = Math.max(b.start, dayStart);
            let bEnd = Math.min(b.end, dayEnd);

            if (bStart > cursor) {
                const gap = bStart - cursor;
                if (gap >= MIN_SLOT_SIZE) {
                    dayFree += gap;
                }
            }
            cursor = Math.max(cursor, bEnd);
        });

        // Хвост дня
        if (cursor < dayEnd) {
            const gap = dayEnd - cursor;
            if (gap >= MIN_SLOT_SIZE) {
                dayFree += gap;
            }
        }

        freeMinutesSum += dayFree;
    }
}

// 5. ИТОГОВЫЕ ЦИФРЫ
// Применяем коэффициент заполняемости 0.8 (невозможно продать 100% времени)
const potentialRevenue = Math.round(freeMinutesSum * pricePerMinute * 0.8);

return {
    json: {
        revenue_fact: earnedMonth,       
        revenue_forecast: forecastMonth, 
        revenue_potential: potentialRevenue, 
        
        visits_fact: visitsFact,         
        visits_forecast: visitsForecast, 
        
        metrics: {
            avg_check: avgCheck,
            hour_price: Math.round(pricePerMinute * 60)
        },
        
        master_id: visitsData.length > 0 ? visitsData[0].master_telegram_id : "unknown"
    }
};
